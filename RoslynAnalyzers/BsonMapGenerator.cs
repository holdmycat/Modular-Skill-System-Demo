using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Ebonor.CodeGen
{
    [Generator]
    public class BsonMapGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context)
        {
            // Register a syntax receiver that will be created for each generation pass
            context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            // Retrieve the populated receiver
            if (!(context.SyntaxContextReceiver is SyntaxReceiver receiver))
                return;

            // Create the source code for the registry
            var sourceBuilder = new StringBuilder();
            sourceBuilder.AppendLine("// <auto-generated/>");
            sourceBuilder.AppendLine("using System;");
            sourceBuilder.AppendLine("using MongoDB.Bson.Serialization;");
            sourceBuilder.AppendLine("using Ebonor.DataCtrl;"); // Assuming your data classes are here or sub-namespaces
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine("namespace Ebonor.DataCtrl");
            sourceBuilder.AppendLine("{");
            sourceBuilder.AppendLine("    public static class GeneratedTypeRegistry");
            sourceBuilder.AppendLine("    {");
            sourceBuilder.AppendLine("        public static void RegisterAllBsonClassMaps()");
            sourceBuilder.AppendLine("        {");

            // Iterate over the collected classes
            foreach (var classSymbol in receiver.CandidateClasses)
            {
                // We need the full type name (namespace.classname)
                var fullTypeName = classSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                
                // Generate the registration call
                sourceBuilder.AppendLine($"            if (!BsonClassMap.IsClassMapRegistered(typeof({fullTypeName})))");
                sourceBuilder.AppendLine($"                BsonClassMap.LookupClassMap(typeof({fullTypeName}));");
            }

            sourceBuilder.AppendLine("        }");
            sourceBuilder.AppendLine("    }");
            sourceBuilder.AppendLine("}");

            // Add the source file to the compilation
            context.AddSource("GeneratedTypeRegistry.g.cs", SourceText.From(sourceBuilder.ToString(), Encoding.UTF8));
        }

        /// <summary>
        /// Created on demand for each generation pass
        /// </summary>
        class SyntaxReceiver : ISyntaxContextReceiver
        {
            public List<INamedTypeSymbol> CandidateClasses { get; } = new List<INamedTypeSymbol>();

            /// <summary>
            /// Called for every syntax node in the compilation, we can inspect the nodes and save information for the Execute phase.
            /// </summary>
            public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
            {
                // We are looking for ClassDeclarations with attributes
                if (context.Node is ClassDeclarationSyntax classDeclarationSyntax && classDeclarationSyntax.AttributeLists.Count > 0)
                {
                    // Get the symbol for the class
                    var classSymbol = context.SemanticModel.GetDeclaredSymbol(classDeclarationSyntax) as INamedTypeSymbol;
                    if (classSymbol == null) return;

                    // Check if the class has the [BsonDeserializerRegister] attribute
                    // Note: We check by name string to avoid dependency issues if the attribute is in a different assembly not referenced by the generator project itself directly in a weird way, 
                    // but usually checking symbol is better. For simplicity/robustness in this demo:
                    if (classSymbol.GetAttributes().Any(ad => ad.AttributeClass.Name == "BsonDeserializerRegisterAttribute" || ad.AttributeClass.Name == "BsonDeserializerRegister"))
                    {
                        CandidateClasses.Add(classSymbol);
                    }
                }
            }
        }
    }
}
