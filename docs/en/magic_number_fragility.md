# Technical Analysis: Implicit Numeric Contracts ("Magic Numbers")

**Status**: Identified Risk
**Severity**: High (Maintenance & Extensibility)
**Topic**: `ActorNumericComponentBase` and `eNumericType` architecture.

---

## 1. Problem Definition: Implicit Knowledge Dependency

The current implementation relies on an implicit mathematical relationship between attribute IDs:
```csharp
// Implicit Formula:
// BaseID  = TypeID * 10 + 1
// AddID   = TypeID * 10 + 2
eNumericType baseType = (eNumericType)((int)type * 10 + 1);
```

### Core Issues
1.  **Cognitive Load**: The system requires every developer to memorize and strictly adhere to this formula. It is not enforced by the compiler or the type system.
2.  **Invisible Dependencies**: There is no explicit link between `HP` (100) and `HP_Base` (1001). This relationship exists only in the runtime logic, making static analysis and refactoring difficult.
3.  **Fragile ID Space**: The formula `* 10` implicitly reserves a block of 10 IDs for each attribute. This creates a rigid "namespace" that cannot easily accommodate more than 10 sub-attributes (e.g., if future requirements demand `FinalAdd`, `PVP_Mult`, `Debuff_Mult`).

---

## 2. Risk Analysis: The "Bus Factor"

The primary risk is not external configuration errors, but **internal development fragility**.

### Scenario: ID Collision
If a developer unknowingly assigns a new attribute ID that conflicts with a reserved "derived" ID (e.g., assigning `NewStat = 101` when `HP` is `100`), the system will silently overwrite the `HP_Base` value (1001) with `NewStat` logic.
*   **Consequence**: Silent data corruption that is difficult to debug.
*   **Root Cause**: The system relies on "Honor System" ID allocation rather than automated enforcement.

---

## 3. Proposed Solution: Schema-Driven Development

To eliminate implicit contracts, we propose shifting from **Manual Enum Management** to **Schema-Driven Code Generation**.

### Architecture Overview
1.  **Schema (Source of Truth)**: Define the structure of attributes in a configuration file (e.g., `AttributeSchema.json`).
2.  **Generator (Automation)**: A build-time tool reads the schema and generates the `eNumericType` enum.

### Implementation Example

**Step 1: Define Schema**
```json
{
  "Attributes": [
    { "Name": "HP", "Components": ["Base", "Add", "Mult"] },
    { "Name": "Mana", "Components": ["Base", "Add"] }
  ]
}
```

**Step 2: Generate Code**
The generator produces sequential, explicitly named IDs:
```csharp
// <auto-generated>
public enum eNumericType {
    HP_Final = 0,
    HP_Base = 1,
    HP_Add = 2,
    HP_Mult = 3,
    
    Mana_Final = 4,
    Mana_Base = 5,
    Mana_Add = 6
}
// </auto-generated>
```

### Benefits
1.  **Explicit Contracts**: The relationship between attributes is defined in data, not hidden in math.
2.  **Collision Safety**: The generator guarantees unique, sequential IDs.
3.  **Extensibility**: Adding a new component (e.g., `Mult`) is a schema change, not a code refactor. The generator handles the ID re-allocation.
4.  **Maintainability**: Reduces the cognitive load on developers. The "how" of ID allocation is abstracted away.
