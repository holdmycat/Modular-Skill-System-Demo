# 技术分析：隐式数值契约 ("Magic Numbers")

**状态**：已识别风险
**严重级**：高 (维护性与扩展性)
**主题**：`ActorNumericComponentBase` 与 `eNumericType` 架构分析

---

## 1. 问题定义：隐式知识依赖 (Implicit Knowledge Dependency)

当前的实现依赖于属性 ID 之间隐含的数学关系：
```csharp
// 隐式公式：
// 基础值 ID = 类型 ID * 10 + 1
// 附加值 ID = 类型 ID * 10 + 2
eNumericType baseType = (eNumericType)((int)type * 10 + 1);
```

### 核心问题
1.  **认知负担 (Cognitive Load)**：系统要求每位开发者必须记忆并严格遵守此公式。编译器或类型系统无法对此进行强制约束。
2.  **不可见依赖 (Invisible Dependencies)**：`HP` (100) 与 `HP_Base` (1001) 之间的联系仅存在于运行时逻辑中，导致静态分析和重构变得极其困难。
3.  **脆弱的 ID 空间 (Fragile ID Space)**：`* 10` 的公式隐式地为每个属性预留了 10 个 ID 的块。这创建了一个僵化的“命名空间”，难以适应未来超过 10 个子属性的需求（例如：若未来需求增加 `FinalAdd`, `PVP_Mult`, `Debuff_Mult`）。

---

## 2. 风险分析：开发脆弱性

主要风险不在于外部配置错误，而在于**内部开发的脆弱性**。

### 场景：ID 冲突 (ID Collision)
如果开发者在不知情的情况下分配了一个新的属性 ID，而该 ID 恰好与某个保留的“衍生” ID 冲突（例如：当 `HP` 为 `100` 时，分配 `NewStat = 101`），系统将会在运行时静默地用 `NewStat` 的逻辑覆盖 `HP_Base` (1001) 的值。
*   **后果**：导致难以排查的数据静默损坏。
*   **根因**：系统依赖于“君子协定”式的 ID 分配，而非自动化强制执行。

---

## 3. 提议方案：模式驱动开发 (Schema-Driven Development)

为了消除隐式契约，我们建议从 **手动枚举管理** 转向 **模式驱动的代码生成**。

### 架构概览
1.  **模式 (单一事实来源)**：在配置文件（如 `AttributeSchema.json`）中定义属性的结构。
2.  **生成器 (自动化)**：构建时工具读取模式并自动生成 `eNumericType` 枚举。

### 实现示例

**步骤 1：定义模式**
```json
{
  "Attributes": [
    { "Name": "HP", "Components": ["Base", "Add", "Mult"] },
    { "Name": "Mana", "Components": ["Base", "Add"] }
  ]
}
```

**步骤 2：生成代码**
生成器产生顺序的、显式命名的 ID：
```csharp
// <auto-generated>
public enum eNumericType {
    HP_Final = 0,
    HP_Base = 1,
    HP_Add = 2,
    HP_Mult = 3,
    
    Mana_Final = 4,
    Mana_Base = 5,
    Mana_Add = 6
}
// </auto-generated>
```

### 收益
1.  **显式契约**：属性之间的关系由数据定义，而非隐藏在数学公式中。
2.  **冲突安全**：生成器保证 ID 的唯一性和顺序性。
3.  **可扩展性**：添加新组件（如 `Mult`）仅需修改模式，无需重构代码。生成器会自动处理 ID 的重新分配。
4.  **可维护性**：降低开发者的认知负担。ID 分配的细节被抽象化处理。
